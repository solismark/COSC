# Day 1
Link to Handbook:

https://cted.cybbh.io/tech-college/pns/public/pns/latest/guides/Day_1_WOBC_Student_Guide.html

Getting into Windows Terminal Workstation:
Password = password
```
xfreerdp /u:student /v:10.50.21.242 -dynamic-resolution +glyph-cache +clipboard
```

Powershell ISE as administrator


## Run Selection, Run All
F8 - runs the selection
F5 - runs the whole script
Stop will allow you to stop the script 
Can be working on multiple scripts at a time using the black paper (Control N)


## Show-Command
allows you to get a GUI with all the commands


## Get-Help
can use the commandlet or just use google
powershell "get-help" that has powershell documentation


## Format-Table
Allows you to format the information in a table like manner


## Format-List
Will list whatever you pass to it
```
Get-Help | Format-List

```

## -detailed
will give more information than initally given


## Comments
Single line comments start with "#" then you would type the exmplanation of the command
Paragraph commands start with the <# and ends with #> to start and end a paragraph text comment


## Variables
```
$var = 1

```
Highlight and F8 will show what the variable is

Integars
Floats
Boolean
Strings

## Typecasting

```
$var + 1
2

[string]$var + 'Hellow'
1Hellow

[bool]$var

[float]$var

[int]$var
```

## Get-Member
Will get methods that you can perform wuth the variable


## .GetType()
will get the type of variable


## Pull Values from Table
```
$var.GetType().name
Int32
```
This will give you a table and then the .name will pull the information value from the table


## Automatic Variables
already created and maintained by powershell
$False
	

False

$True
	

True

$Null
	

Empty value

$$
	

Last Token used

$?
	

Execution status of last operation

$^
	

First Token in last line received

$_ or $PSItem
	

Object in current pipeline

$Args
	

Array of undeclared parameters and/or values

$Error
	

Most recent error

$Home
	

full path of user’s home directory

$Host
	

Current host application

$Input
	

Enumerator that enumerates all input passed to a function

$LastExitCode
	

exit code of the last Windows-based program that was run

$Matches
	

Hash Table of RegEx matches

$PID
	

PID of current PS session

$Profile
	

Full path of current user and host application

$PSVersionTable
	

Details about Windows PowerShell

$PSHome
	

the full path of the installation directory for PowerShell

$Pwd
	

Full path of current directory


## Arrays
```
$myarray = 'Hellow', 12, (get-date), $False
$myarray.GetType().BaseType.Name

```


## Indexing
```
$myarray = 'Hellow', 12, (get-date), $False

$myarray[0]
Hellow

$myarray[0][1]
e

$myarray[0][5]
w
```
indexing is the same as in python


## Nested Arrays
```
$var += 1
2

$newarray = @()  # Multi Array using @() empty array

$newarray.GetType()
Array

$newarray += 1
1

$newarray += 2
1
2
```


Multifunctional array
```
$myarray = @((1,2,3,4)(5,6,7,8)) # Jagged Array
1
2
3
4
5
6
7
8

$myarray[0]
1
2
3
4

$myarray[0][2]
3

$myarray = @((1,2,3,4)(5,6,7,8), 'Hellow')
1
2
3
4
5
6
7
8
Hellow

$myarray += 'World'
1
2
3
4
5
6
7
8
Hellow
World

```

## Pipeline " | "
```
Get-Process | Get-Member -MemberType Properties

Get-Process | Get-Member -MemberType Method

Get-Service | Format-List

Get-Service | Format-Table

Get-Service | Format-Table Name, Status

Get-Service | Where-Object -Property Status -EQ stopped;`
Format-Table Name, status



Get-Help | Format-List

```


## Sort
```
Get-Process | sort -Property Name
Get-process | get-member | where-object -property name -EQ ID
```

## Aliases
Get-Alias

```
Get-Alias ls
ls - Get-ChildItem

```

Setting Alias
```
Set-Alias edit notepad.exe

edit # Should Open Notepad.exe
```


## ()

```
$var = [int](Read-Host)
$var + 2
{Read-Host}
```

## Word Wrapping

```
Get-Alias gal; Get Alias dir; Get-Alias; echo;`
 Get-Alias echo; Get-Aslias %
```

## Formatting Input
'''
"{0} + {1} = {2}" -f $var1, $var2, $var3
37 + 2 = 39


'''
-f is allowing you to list and us the positions to pass the list positions into the curly brackets { }


## Practical Practice 1


Ensure that you have the latest copy of help by updating your help system.

```
update-help
```

Which cmdlets deal with the viewing/manipulating of processes?

```
Get-Help *process*

Get-Command -noun Process

Get-Process
```
Display a list of services installed on your local computer.
```
Get-Services
```

What cmdlets are used to write or output objects or text to the screen?
```
Write-Host
Write-Error
Write-Output
Write-Host

```

```
Write-Warning “This is an example warning.”
WARNING: Warning

Write-Error “This is an example error.”
This is an example of error

Write-Output (1+2)
3

Write-Host “This text will be displayed on the screen.”
This text will be displayed on the screen.
```

get-help *write*

What cmdlets can be used to create, modify, list, and delete variables?

```
Get-Help -noun Variable


Get-Variable # Gets variables within the current console

New-Variable # Creates a new variable

Remove-Variable # Deletes a variable and its value

Set-Variable # Changes the value of a variable

```


What cmdlet can be used, other than Get-Help, to find and list other cmdlets?

```
Get-Command
```

Find the cmdlet that is used to prompt the user for input.

```
Read-Host # Input recieves a string

$a = Read-Host "Say something"
Say something:
$a
hello

$var = [int](Read Host)

or

$var = Read Host
[int]$var + 2
$var
3
```
Takes user input and asigns it to the variable or can just read from the host 


## Practical Practice 2



Display a list of running processes.

```
Get-Process

```

Display a list of all running processes that start with the letter "s".

```
Get-Process -name S*

```

Find the cmdlet and its purpose for the following aliases:

gal
```
gal -> Get-Alias
```


    Display the start time of the earliest and latest running processes

    Identify a cmdlet that returns the current date and time then using this cmdlet and Select-object, display only the current day of the week

    Identify a cmdlet that displays a list of installed hotfixes.

    Extend the expression to sort the list by install date, and display only the install date and hotfix ID.

    Extend the expression further, but this time sort by description, include description, hotfix ID, and install Date.


dir
```
dir -> Get-ChildItem
```

echo
```
echo -> Write-Output
```

?
```
? -> Where-Object
```

%
```
% -> ForEach-Object
```

ft
```
ft -> Format-Table

```

Display a list of Windows Firewall Rules.

```
Show-NetFirewallRules

```

Create a new alias called "gh" for the cmdlet "Get-Help"

```
Set-Alias gh Get-Help

gal gh

gh -> Get-Help
```


## Practice Practical 3

Create a variable called "var1" that holds a random number between 25-50.

```
$var = Invoke-Command { Get-Random -Minimum 25 -Maximum 50 }

$var1 = Get-Random -Minimum 25 -Maximum 51
 

    Display the start time of the earliest and latest running processes

    Identify a cmdlet that returns the current date and time then using this cmdlet and Select-object, display only the current day of the week

    Identify a cmdlet that displays a list of installed hotfixes.

    Extend the expression to sort the list by install date, and display only the install date and hotfix ID.

    Extend the expression further, but this time sort by description, include description, hotfix ID, and install Date.



```
-Maximum needs to be 1 above what the actual value is



Create a variable called "var2" that holds a random number between 1-10.

```
$var = Invoke-Command { Get-Random -Minimum 1 -Maximum 10 }

```

Create a variable called "sum" that holds the sum of var1 and var2.

```
$sum = $var1 + $var2


```


Create a variable called "sub" that holds the difference of var1 and var2.

```
$sub = $var1 - $var2
```

Create a variable called "prod" that holds the product of var1 and var2.

```
$prod = $var1 * $var2
```

Create a variable called "quo" that holds the quotient of var1 and var2.

```
$quo = $var1 / $var2
```
Replace the variables in text with their values in the following format:


"44" + "7" = "51"

```
""$var1 + $var2""




```
Replace the variables in text with their values in the following format:

"44" - "7" = "37"


Replace the variables in text with their values in the following format:

"44" * "7" = "308"


Replace the variables in text with their values in the following format:

"44" / "7" = "6.28571428571429"


"{0} + {1} = {2}" -f $var1, $var2, $var3

## Practice Practical 4



Create an array containing a range with a random starting and stopping point. The starting point will be a random number from -10 through 0. The ending point will be a random number from 1 through 20.

For example, if the first random number is -3, and the second random number is 2, your array will be -3, -2, -1, 0, 1, 2

```
$array = (Get-Random -Minimum -10 -Maximum 1)..(Get-Random -Minimum 1 -Maximum 21)
($array.Length)-1

$reverse = $array[($array.Length-1)..0]

PS C:\windows\system32> $array
-2
-1
0
1
2
3
4
5

PS C:\windows\system32> $reverse
5
4
3
2
1
0
-1
-2

```

Create a variable that contains the contents of the array in reverse

Using the above example, your reversed array will be 2, 1, 0, -1, -2, -3 


## Hashtable

```
$a = {}
$a.GetType()
Hashtable

```

Get-ChildItem

## Functions

```
function Get-Head {
Write-Host "Coors Light"
Write-Host "Coors Banquet"
Write-Host "Four Loko"
Write-Host "Yeungling"
}

PS C:\windows\system32> Get-Head
Coors Light
Coors Banquet
Four Loko
Yeungling

Get-Head | sort



```

## {} vs ()

() if code is in parenthisis it will automatically run

{} has to be invoked using invoke-command
Invoke-Command {Command} or &{Command}


## Practice Exersice: Arrays & Hash Tables

```
$employee1 = [ordered]@{}
$employee2 = @{}
$employee1.First = "Mary"
$employee1["Last"] = "Hopper"
$employee1.ID = "001"
$employee1["Job"] = "Software Developer"

$employee2.First = "John"
$employee2["Last"] = "Williams"
$employee2.ID = "002"
$employee2["Job"] = "Software Developer"
```
## Get-Member

```
Get-date | Get-Member

```
will give you all the fictions for that command



## Practice Exercise : The Pipeline



Display the start time of the earliest and latest running processes

```
Get-Process | select name,starttime | sort -Descending Starttime | select-object -First 1
Get-Process | select name,starttime | sort -Descending Starttime | select-object -Last 1

(Get-Process | Where-Object{$_.item.Starttime} | Measure-Object).count


Get-Process | Measure-Object -Property Starttime -Minimum -Maximum | Select-Object Minimum, Maximum

Minimum              Maximum             
-------              -------             
6/10/2024 1:23:47 PM 6/25/2024 1:14:22 PM


(Get-Process | Measure-Object -Property Starttime -Minimum -Maximum | Select-Object Minimum, Maximum).minimum

Monday, June 10, 2024 1:23:47 PM

```


Identify a cmdlet that returns the current date and time then using this cmdlet and Select-object, display only the current day of the week

```

Get-Date | Select-Object -ExpandProperty DayOfWeek

```


Identify a cmdlet that displays a list of installed hotfixes.

```
Get-Hotfix

```

Extend the expression to sort the list by install date, and display only the install date and hotfix ID.

```
Get-hotfix | sort -Descending Installedon | select InstalledOn, HotFixID

Get-HotFix | Sort-Object InstalledOn | Select-Object Installedon, HotfixID



```

Extend the expression further, but this time sort by description, include description, hotfix ID, and install Date.

```
Get-hotfix | sort -Descending Description | select -Property Description, HotfixID, InstalledOn

(Get-HotFix | Sort-Object Description | Select-Object Description, InstalledOn, HotfixID).description[-1]


```




you can use the ().count to index the position of the list and grab the information out


## Get-Member

## Measure-Object 
does count by default
and you have to specify the value you want



# Day 2

## Practical Exercise: Custom Object


Create a custom object that contains information about the host system using the following:

    Win32_ComputerSystem

    Win32_BIOS

    Win32_OperatingSystem

    Win32_LogicalDisk

```
$computer = New-Object -TypeName psobject    # Creates the Object

$compinfo = (Get-WmiObject win32_computersystem).name       ## You are pulling the info located at the .name
$osinfo = (Get-WmiObject win32_operatingsystem).caption     ## You are pulling the info located at the .caption
$osveinfo = (Get-WmiObject win32_operatingsystem).version   ## You are pulling the info located at the .version
$osbios = (Get-WmiObject win32_bios).manufacturer           ## You are pulling the info located at the .manufacturer
$diskinfo = (Get-WmiObject win32_logicaldisk).path.path     ## You are pulling the info located at the .path.path


$computer | Add-Member -MemberType NoteProperty -Name ComputerName -Value $compinfo    # Adding to the Object Properties
$computer | Add-Member -MemberType NoteProperty -Name OperatingSystem -Value $osinfo   # Adding to the Object Properties
$computer | Add-Member -MemberType NoteProperty -Name OSVersion -Value $osveinfo       # Adding to the Object Properties
$computer | Add-Member -MemberType NoteProperty -Name BIOS -Value $osbios              # Adding to the Object Properties
$computer | Add-Member -MemberType NoteProperty -Name Disk -Value $diskinfo            # Adding to the Object Properties


Get-WMIobject Win32_Computersystem | Get-Member -MemberType Properties | Where-Object {$_.name -like '*name*'}
			# Used to search through to locate desired property



```

## Creating Objects
each property can be accessed using .notation

```
$computer = New-Object -TypeName psobject

```

will create a new object

## Searching Properies for the object

```
Get-WMIobject Win32_Computersystem | Get-Member -MemberType Properties | Where-Object {$_.name -like '*name*'}
```

## Adding to Custom Objects

```

$computer | Add-Member -MemberType NoteProperty -Name ComputerName -Value $compinfo    # Adding to the Object Properties
$computer | Add-Member -MemberType NoteProperty -Name OperatingSystem -Value $osinfo   # Adding to the Object Properties
$computer | Add-Member -MemberType NoteProperty -Name OSVersion -Value $osveinfo       # Adding to the Object Properties
$computer | Add-Member -MemberType NoteProperty -Name BIOS -Value $osbios              # Adding to the Object Properties
$computer | Add-Member -MemberType NoteProperty -Name Disk -Value $diskinfo            # Adding to the Object Properties


```



## Script Block (Invoking Commands)

{ get-service | format-table name,status }

```
$myblock = { get-service | format-table name,status }

Invoke-Command $myblock
&myblock
```


```

$a = 1
$b = {1+1}

$a + &$b
3
```
ways to invoke your commands


## Group-Object

```
Get-Process | Group-Object Name | Sort -Property count

Get-Process | Group-Object {$_.Name}

Get-Process | Group-Object {$_.Name.Substring(0,1).ToUpper()}
$
```
.name 

.substring is grouping based on the 1st index letter 

.ToUpper() is making everything caps


```

Get-Process | Group-Object {$_.Name.Substring(0,1).ToUpper()} | ForEach-Object {($_.Name + " ") * 7; "============="; $_.group}


```
Making headers and see groups


## Sort-Object

```
Get-Process | Sort-Object sarttime | Select-Object -Last 10 | ft processname, starttime

PS C:\windows\system32> Get-Process | Sort-Object sarttime | Select-Object -Last 10 | ft processname, starttime

ProcessName           StartTime           
-----------           ---------           
smss                  6/10/2024 1:24:00 PM
sihost                6/25/2024 8:53:20 AM
ShellExperienceHost   6/25/2024 8:55:42 AM
SgrmBroker            6/10/2024 1:27:35 PM
services              6/10/2024 1:24:41 PM
SecurityHealthSystray 6/25/2024 8:53:52 AM
SecurityHealthService 6/10/2024 1:49:01 PM
SearchIndexer         6/10/2024 1:27:42 PM
SearchApp             6/25/2024 8:53:38 AM
WUDFHost              6/25/2024 8:53:15 AM


Select-Object -ExpandProperty name


```


## Where-Object

```



```


## Comparison Operators

https://cted.cybbh.io/tech-college/pns/public/pns/latest/guides/Day_2_WOBC_Student_Guide.html#_comparison_operators

-eq, -ceq

Equals

-ne, -cne
	
Not Equal

-gt, -cgt
	
Greater Than

-lt, -clt

Less Than

-ge, -cgt
	
Greater Than or Equal To

-le, -cle

Less Than or Equal To

Conditions

```
2 -eq 2
True

2 -eq 3
False

1..5 -eq 3
3


PS C:\windows\system32> "Abc" -ceq "abc"
False

PS C:\windows\system32> "Abc" -eq "abc"
True

1..5 -gt 3
4
5

"Abc", "def", "ghi" -eq "abc"
Abc
```



## Matching

-like, -clike

String matches wildcard pattern

-notlike, -cnotlike
	
String does not match wildcard pattern

-match, cmatch
	
String matches regex pattern

-notmatch, -cnotmatch

String does not match regex pattern


## Like

```
"powershell" -like "*shell"
True

"powershell", "server" -like "*shell"
powershell

"powershell", "server" -like "*s*"
powershell
server

"powershell", "server" -notlike "*shell"
server

```

## Matches

```

$text = 'Here is the model number: MO5364'
$pattern = 'MO(\d{3})'
$text -match $pattern

$Matches[0]


```

## Contains

icontains insensitive 
ccontains case sensitive
contains contains

```
$beer = 'spotted cow', 'lefthand brewery', "kneedeep", "coors light"

$beer = 'spotted cow', 'lefthand brewery', "kneedeep", "coors light"
$beer -contains 'coors light'
True

$beer = 'spotted cow', 'lefthand brewery', "kneedeep", "coors light"
$beer -contains 'coors'
False

$beer = 'spotted cow', 'lefthand brewery', "kneedeep", "coors light"
$beer -ccontains 'coors light'    # ccontains Case sensitive
True

$beer = 'spotted cow', 'lefthand brewery', "kneedeep", "coors light"
$beer -contains 'Coors light'     # ccontains Case sensitive
False
```



## If Elseif Else

```
if (condition){
	code to be executed
}
elseif (condition){
	code to be executed
}
elseif (condition){
	code to be executed
}
elseif (condition){
	code to be executed
}
else {
}

```

```
$x = 11
if($x -gt 10){"$x is larger than 10"}



```

## ForEach-Object

```
$sum = 0
1..5 | ForEach-Object {$sum += $_}

$letterarray = 'a', 'b', 'c', 'd'
foreach ($letter in $letterarray)
{
	write-host $letter
}

```


## Practical Exersice: Comparison and Condition

```
$line1 = "Do you have model number: MT5437 for john.doe@sharklasers.com?"
$line2 = "What model number for john.doe@sharklasers.com?"
$lines = @()
$lines += $line1
$lines += $line2
foreach ($line in $line1 + $line2)
if ($line -match 'MT5437'){Write-Host $line has the model number}
elseif ($line -match 'MT5437'){Write-host $line doesnt have the model number}
}
```

Another example with adding two strings to an array
```

$line1 = "Do you have model number: MT5437 for john.doe@sharklasers.com?"
$line2 = "What model number for john.doe@sharklasers.com?"
$lines = @()
$lines += $line1
$lines += $line2
foreach ($a in $lines){
if ($a -match "MT5437"){Write-Host ($a):has the model number.}
else {Write-host ($a):doesnt have model number.}
}

Do you have model number: MT5437 for john.doe@sharklasers.com? :has the model number.
What model number for john.doe@sharklasers.com? :doesnt have model number.
```

Answer:

```
$line1 = "Do you have model number: MT5437 for john.doe@sharklasers.com?"
$line2 = "What model number for john.doe@sharklasers.com?"
$pattern = '[A-Za-z]{2}\d{2,5}'
$line1, $line2 | ForEach-Object {
     if ($_ -match $pattern){
        Write-Host $Matches[0]": $_";
     }
     else{
        Write-Host "No matches found on: $_";
     }
}

MT5437 : Do you have model number: MT5437 for john.doe@sharklasers.com?
No matches found on: What model number for john.doe@sharklasers.com?
```

## foreaech 
used to iterate over a collection of objects

```
$array = 1..5
foreach ($item in $array){
	Write-Host $item
}
```

```
PS C:\windows\system32> $array = 1..5
$sum = 0
foreach ($item in $array){
	Write-Host $item
    $sum += $item
}
1
2
3
4
5

PS C:\windows\system32> $sum
15

```


## while

```
while(condition) {
	Code
}
```

```

while($true){
	'This is true'
}


```


```
PS C:\windows\system32> $sum = 0
while($sum -lt 15){
	$sum
	$sum += 1
}

0
1
2
3
4
5
6
7
8
9
10
11
12
13
14
```

```
$beer = ''
while($beer -ne 'coors') {
	$beer = Read-Host -Prompt "What is the best beer?"
}


PS C:\windows\system32> $beer = ''
while($beer -ne 'coors') {
	$beer = Read-Host -Prompt "What is the best beer?"
}
What is the best beer?: Coors

```


## dowhile
while the condition is true it will run
no matter what will run atleast once

 ProcessIDs to a text file called procs.txt
```
do {
	code block
}until(condition)

```

```
$num = 0
do {
	$num
	$num += 1
}until($num -gt 3)

```
```
PS C:\windows\system32> $num = 0
do {
	$num
	$num += 1
}until($num -gt 3)

0
1
2
3


```

## dountil
do until the condition is true
no matter what will run atleast once


```
do {
	code block
}while(condition)

```

```
$num = 0
do {
	$num
	$num += 1
}while($num -lt 3)

```

```
PS C:\windows\system32> $num = 0
do {
	$num
	$num += 1
}while($num -lt 3)

0
1
2

```

```
PS C:\windows\system32> $num = 100
do {
	$num
	$num += 1
}while($num -lt 3)

100

PS C:\windows\system32> $num
101



```

## for loop

```
for (initialization; condition; increment)
{
	code block
}
```


```
PS C:\windows\system32> for ($num = 1; $num -le 3; $num ++)
{
    $num
}
1
2
3

```

## break continue

## Set-Content 

```
Set-Content -Path .\example.txt -Value "Hello"


```

## Get-Content

```
Get-Content .\example.txt
Hello

```

## Add-Content

```
Add-Content -Path .\example.txt -Value "Gatorade is better"

```


## Practical Exercise: Looping & Iteration
Part 1 and 2
```
$proc = "notepad", "msedge", "mspaint"
$proc | ForEach-Object {
    Start-Process $_
}

$proc | ForEach-Object {
   (Get-process $_).Id | Add-Content -Path .\ProcID.txt
}

$proc | ForEach-Object {
    Stop-Process -Name $_
}


```


Part 3

```
$proc = "notepad", "msedge", "mspaint"
$proc | ForEach-Object {
Start-Process $_
}

$file = "$PWD\proc.txt"
foreach($procs in $proc){
Get-Process | Where-Object {$_.Name -like $procs} | ForEach-Object{Add-Content $file $_.id}
}

Get-Content -Path $file | ForEach-Object{Stop-Process -id $_}


```
```
$proc = "notepad", "msedge", "mspaint"
$proc | ForEach-Object {
    Start-Process $_
}

$file = "$PWD\proc.txt"
foreach($procs in $proc){
   Get-Process | Where-Object {$_.Name -like $procs} | ForEach-Object{Add-Content $file $_.id}
}

Get-Content -Path $file | ForEach-Object{Stop-Process -id $_}
$proc = "notepad", "msedge", "mspaint"
foreach($procs in $proc){
    Get-Process | Where-Object {$_.Name -like $procs} | Format-Table -Property id,name,starttime,totalprocessortime
}

```

## Practical Exercise : Creating a Function

Write a function that returns the Ordinal date of the current date.
```
function od{
$date=(Get-Date).dayofyear
$year=(Get-date).Year
Write-Host $year"-"$date

}

PS C:\windows\system32> od
2024-179
```

Create a function that takes a number(n) as an argument and returns the square(n^2) of the number.

```
function Get-SquareNum([int]$num){
    $result = $num * $num
    $result
}


PS C:\windows\system32> Get-SquareNum 4
16

PS C:\windows\system32> Get-SquareNum 5
25

PS C:\windows\system32> Get-SquareNum 9
81
```

Create a function that takes three (3) arguments and returns the product of the arguments.

```
function Get-Product($val1, $val2, $val3){
	return $val1 * $val2 * $val3
}

PS C:\windows\system32> Get-Product 1 1 1
1

PS C:\windows\system32> Get-Product 2 2 2
8

PS C:\windows\system32> Get-Product 4 4 4
64

```



